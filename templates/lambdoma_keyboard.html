{% extends 'base.html' %} {% block title %}Lambdoma Keyboard{% endblock %} {%
block head %}
<style>
	.lambdoma-grid {
		display: grid;
		grid-template-columns: repeat(var(--grid-size, 16), minmax(0, 1fr));
		grid-template-rows: repeat(var(--grid-size, 16), minmax(0, 1fr));
		border: 1px solid #4b5563; /* gray-600 */
		aspect-ratio: 1 / 1;
		max-width: 70vh; /* Limit size */
		max-height: 70vh;
		margin: auto;
	}
	.lambdoma-cell {
		border: 1px solid #374151; /* gray-700 */
		display: flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		font-size: 0.6rem; /* Adjust as needed */
		line-height: 1;
		text-align: center;
		color: rgba(255, 255, 255, 0.7);
		transition: all 0.1s ease-in-out;
		position: relative;
		overflow: hidden;
	}
	.lambdoma-cell:hover {
		border-color: #d1d5db; /* gray-300 */
		color: white;
		z-index: 10;
		transform: scale(1.1);
		box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
	}
	.lambdoma-cell.active {
		border: 2px solid white;
		transform: scale(1.1);
		z-index: 20;
	}
	#lissajous-canvas {
		border: 1px solid #4b5563; /* gray-600 */
		background-color: #1f2937e0; /* gray-800 with transparency */
		aspect-ratio: 1 / 1;
		width: 100%;
		max-width: 300px; /* Adjust size */
	}
	/* Ensure consistent sizing between grid and canvas containers */
	.keyboard-container {
		max-width: 70vh;
		margin: auto;
	}
	.visual-container {
		max-width: 300px;
	}
</style>
{% endblock %} {% block content %}
<div class="p-4 md:p-8 flex flex-col items-center">
	<h1 class="text-3xl font-serif text-primary mb-6">Lambdoma Keyboard</h1>

	<div
		class="flex flex-col md:flex-row gap-8 items-center justify-center w-full"
	>
		<!-- Lambdoma Grid -->
		<div class="keyboard-container w-full md:w-2/3">
			<div
				id="lambdoma-grid"
				class="lambdoma-grid"
				style="--grid-size: {{ grid_size }};"
			>
				{% for r in range(grid_size) %} {% for c in range(grid_size) %} {% set
				cell = matrix[r][c] %}
				<div
					class="lambdoma-cell"
					style="background-color: {{ cell.color }}30;"
					{#
					Add
					alpha
					transparency
					#}
					title="{{ cell.ratioStr }} | {{ cell.noteName or 'N/A' }} | {{ cell.chakra }} | {{ cell.frequencyHz }} Hz"
					data-row="{{ r + 1 }}"
					{#
					Use
					1-based
					for
					Lissajous
					#}
					data-col="{{ c + 1 }}"
					{#
					Use
					1-based
					for
					Lissajous
					#}
					data-freq="{{ cell.frequencyHz }}"
					data-ratio="{{ cell.ratioStr }}"
					data-color="{{ cell.color }}"
				>
					{{ cell.ratioStr }}
				</div>
				{% endfor %} {% endfor %}
			</div>
		</div>

		<!-- Visual Display -->
		<div class="visual-container w-full md:w-1/3 flex flex-col items-center">
			<h2 class="text-lg font-serif text-secondary mb-4">Harmonic Visual</h2>
			<canvas id="lissajous-canvas" width="300" height="300"></canvas>
			<p id="visual-info" class="text-xs text-text-muted mt-2 text-center">
				Click a cell to visualize resonance
			</p>
			<div class="mt-2 flex items-center">
				<input type="checkbox" id="animation-toggle" class="mr-2" checked />
				<label for="animation-toggle" class="text-xs text-text-muted"
					>Animate Pattern</label
				>
			</div>
		</div>
	</div>

	<div class="mt-4 text-xs text-text-muted">
		Base Frequency: 256 Hz | Grid Size: {{ grid_size }}x{{ grid_size }}
	</div>

	<div class="mt-4 text-center">
		<button
			id="clear-all-button"
			class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded transition-colors"
		>
			Clear All
		</button>
	</div>
</div>

{% endblock %} {% block scripts %}
<script>
	document.addEventListener("DOMContentLoaded", () => {
		const grid = document.getElementById("lambdoma-grid");
		const canvas = document.getElementById("lissajous-canvas");
		const visualInfo = document.getElementById("visual-info");
		const clearAllButton = document.getElementById("clear-all-button");
		const animationToggle = document.getElementById("animation-toggle");
		const ctx = canvas.getContext("2d");

		let audioContext;
		let activeCells = new Map(); // Map to store active cells and their oscillators
		let animationId = null; // Store animation frame ID
		let phaseOffset = 0; // Phase offset for animation
		let animationEnabled = true; // Animation state

		// Initialize animation toggle from checkbox
		animationEnabled = animationToggle.checked;

		// Add event listener for animation toggle
		animationToggle.addEventListener("change", (e) => {
			animationEnabled = e.target.checked;

			// If animation was turned on and we have active cells, start animation
			if (animationEnabled && activeCells.size > 0 && !animationId) {
				animationId = requestAnimationFrame(animateLissajous);
			}
			// If animation was turned off, stop it and render static pattern
			else if (!animationEnabled && animationId) {
				cancelAnimationFrame(animationId);
				animationId = null;

				// Render static pattern for the last active cell
				if (activeCells.size > 0) {
					const lastCell = Array.from(activeCells.entries()).pop();
					if (lastCell) {
						const [cellElement, audioData] = lastCell;
						const row = parseInt(cellElement.dataset.row);
						const col = parseInt(cellElement.dataset.col);
						const color = cellElement.dataset.color;
						renderLissajous(row, col, ctx, color, 0); // Static pattern with phase 0
					}
				}
			}
		});

		// --- Task 3: Web Audio Tone Synthesis ---
		function initAudio() {
			if (!audioContext) {
				try {
					audioContext = new (window.AudioContext ||
						window.webkitAudioContext)();
					console.log("Audio context initialized.");
				} catch (e) {
					console.error("Web Audio API is not supported in this browser", e);
					alert("Web Audio API is not supported in this browser");
					return false;
				}
			}
			// Resume context if suspended (often needed after user interaction)
			if (audioContext.state === "suspended") {
				audioContext
					.resume()
					.catch((e) => console.error("Error resuming audio context:", e));
			}
			return true;
		}

		function playTone(freq, pan = 0, duration = 1.5, cellElement) {
			if (!initAudio() || freq <= 0) return null;

			const oscillator = audioContext.createOscillator();
			const gainNode = audioContext.createGain();
			const pannerNode = audioContext.createStereoPanner();

			oscillator.type = "sine";
			oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

			// Envelope: Quick attack, hold, gentle release
			const now = audioContext.currentTime;
			gainNode.gain.setValueAtTime(0.0001, now);
			gainNode.gain.exponentialRampToValueAtTime(0.3, now + 0.05); // Reduced volume for multiple tones

			// Set panning (-1 left, 0 center, 1 right)
			pannerNode.pan.setValueAtTime(pan, now);

			// Connect nodes: Osc -> Gain -> Panner -> Destination
			oscillator.connect(gainNode);
			gainNode.connect(pannerNode);
			pannerNode.connect(audioContext.destination);

			oscillator.start(now);

			// Return audio nodes so we can stop them later
			return {
				oscillator,
				gainNode,
				pannerNode,
				stop: function () {
					try {
						gainNode.gain.cancelScheduledValues(audioContext.currentTime);
						gainNode.gain.linearRampToValueAtTime(
							0.0001,
							audioContext.currentTime + 0.1
						);
						setTimeout(() => {
							oscillator.stop();
							pannerNode.disconnect();
							gainNode.disconnect();
						}, 100);
					} catch (e) {
						console.warn("Error stopping tone:", e);
					}
				},
			};
		}

		// --- Task 4: Visual Resonance Display ---
		function renderLissajous(xRatio, yRatio, canvasCtx, color, phase = 0) {
			const width = canvasCtx.canvas.width;
			const height = canvasCtx.canvas.height;
			const padding = 20;
			const amplitudeX = width / 2 - padding;
			const amplitudeY = height / 2 - padding;
			const points = 500; // Number of points to draw
			const increment = (Math.PI * 2 * Math.max(xRatio, yRatio)) / points; // Adjust speed based on ratio

			canvasCtx.clearRect(0, 0, width, height);
			canvasCtx.beginPath();
			canvasCtx.strokeStyle = color;
			canvasCtx.lineWidth = 1.5;
			canvasCtx.globalAlpha = 0.8;

			for (let i = 0; i <= points; i++) {
				const t = i * increment;
				// Add phase to create animation
				const x = amplitudeX * Math.sin(xRatio * t + phase);
				const y = amplitudeY * Math.sin(yRatio * t);
				const screenX = width / 2 + x;
				const screenY = height / 2 + y;

				if (i === 0) {
					canvasCtx.moveTo(screenX, screenY);
				} else {
					canvasCtx.lineTo(screenX, screenY);
				}
			}
			canvasCtx.stroke();
			canvasCtx.globalAlpha = 1.0;
		}

		// New function to render a true combined Lissajous pattern
		function renderCombinedLissajous(canvasCtx, phase = 0) {
			if (activeCells.size === 0) return;

			const width = canvasCtx.canvas.width;
			const height = canvasCtx.canvas.height;
			const padding = 20;
			const centerX = width / 2;
			const centerY = height / 2;

			canvasCtx.clearRect(0, 0, width, height);

			// If only one cell is active, use the standard Lissajous
			if (activeCells.size === 1) {
				const [cellElement, audioData] = Array.from(activeCells.entries())[0];
				const row = parseInt(cellElement.dataset.row);
				const col = parseInt(cellElement.dataset.col);
				const color = cellElement.dataset.color;
				renderLissajous(row, col, ctx, color, phase);
				return;
			}

			// For multiple cells, create a true combined visualization
			// Get all active frequencies
			const activeFreqs = Array.from(activeCells.keys()).map((cell) => ({
				x: parseInt(cell.dataset.row),
				y: parseInt(cell.dataset.col),
				color: cell.dataset.color,
			}));

			// Draw the combined pattern
			canvasCtx.beginPath();
			canvasCtx.strokeStyle = "#ffffff"; // Use white for combined pattern
			canvasCtx.lineWidth = 1.5;

			const points = 1000; // More points for smoother curve
			const timeStep = 0.01;

			// Create parametric function that combines all frequencies
			for (let i = 0; i < points; i++) {
				const t = i * timeStep;

				// Sum the contributions of all frequencies for x and y
				let x = 0;
				let y = 0;

				// Use the first half of frequencies for x and second half for y
				const halfPoint = Math.ceil(activeFreqs.length / 2);

				for (let j = 0; j < halfPoint; j++) {
					x += Math.sin(activeFreqs[j].x * t + phase) / halfPoint;
				}

				for (let j = halfPoint; j < activeFreqs.length; j++) {
					y +=
						Math.sin(activeFreqs[j].y * t) / (activeFreqs.length - halfPoint);
				}

				// Scale to canvas
				const amplitudeX = width / 2 - padding;
				const amplitudeY = height / 2 - padding;
				const screenX = centerX + x * amplitudeX;
				const screenY = centerY + y * amplitudeY;

				if (i === 0) {
					canvasCtx.moveTo(screenX, screenY);
				} else {
					canvasCtx.lineTo(screenX, screenY);
				}
			}

			canvasCtx.stroke();

			// Draw small indicators for each active frequency
			activeFreqs.forEach((freq, index) => {
				canvasCtx.beginPath();
				canvasCtx.fillStyle = freq.color;
				canvasCtx.arc(20, 20 + index * 15, 5, 0, Math.PI * 2);
				canvasCtx.fill();
			});
		}

		// Function to animate the Lissajous pattern
		function animateLissajous() {
			if (activeCells.size === 0 || !animationEnabled) {
				if (animationId) {
					cancelAnimationFrame(animationId);
					animationId = null;
				}
				return;
			}

			// Increment phase for animation
			phaseOffset += 0.02;
			if (phaseOffset > Math.PI * 2) {
				phaseOffset -= Math.PI * 2; // Keep within 0-2π range
			}

			// Render the combined visualization
			renderCombinedLissajous(ctx, phaseOffset);

			animationId = requestAnimationFrame(animateLissajous);
		}

		// Function to update the visualization based on active cells
		function updateVisualization() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			if (activeCells.size === 0) {
				visualInfo.textContent = "Click cells to create harmonies";
				if (animationId) {
					cancelAnimationFrame(animationId);
					animationId = null;
				}
				return;
			}

			// Update info text to show number of active tones
			visualInfo.textContent = `${activeCells.size} active tone${
				activeCells.size > 1 ? "s" : ""
			}`;

			// Start animation if enabled and not already running
			if (animationEnabled && !animationId) {
				animationId = requestAnimationFrame(animateLissajous);
			} else if (!animationEnabled) {
				// Render static combined pattern
				renderCombinedLissajous(ctx, 0); // Static pattern with phase 0
			}
		}

		// Function to clear all active cells
		function clearAllCells() {
			activeCells.forEach((audioNodes, cell) => {
				audioNodes.stop();
				cell.classList.remove("active");
			});
			activeCells.clear();
			updateVisualization();

			// Ensure animation stops
			if (animationId) {
				cancelAnimationFrame(animationId);
				animationId = null;
			}
		}

		// Clear all button event listener
		clearAllButton.addEventListener("click", clearAllCells);

		// --- Task 2: Grid Interaction ---
		grid.addEventListener("click", (event) => {
			const cell = event.target.closest(".lambdoma-cell");
			if (!cell) return;

			const freq = parseFloat(cell.dataset.freq);
			const ratioStr = cell.dataset.ratio;
			const color = cell.dataset.color;
			const row = parseInt(cell.dataset.row); // 1-based
			const col = parseInt(cell.dataset.col); // 1-based
			const gridSize = grid.children.length > 64 ? 16 : 8; // Determine grid size

			// Determine pan based on column position
			const panValue = ((col - 1) / (gridSize - 1)) * 2 - 1;

			// Toggle cell activation
			if (activeCells.has(cell)) {
				// Deactivate cell
				const audioNodes = activeCells.get(cell);
				audioNodes.stop();
				activeCells.delete(cell);
				cell.classList.remove("active");
			} else {
				// Activate cell
				if (!isNaN(freq) && freq > 0) {
					const audioNodes = playTone(freq, panValue, Infinity, cell);
					if (audioNodes) {
						activeCells.set(cell, audioNodes);
						cell.classList.add("active");
					}
				}
			}

			updateVisualization();
		});

		// Initialize audio on first interaction (good practice)
		document.body.addEventListener("click", initAudio, { once: true });
	});
</script>
{% endblock %}
