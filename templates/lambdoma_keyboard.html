{% extends 'base.html' %} {% block title %}Lambdoma Keyboard{% endblock %} {%
block head %}
<style>
	.lambdoma-grid {
		display: grid;
		grid-template-columns: repeat(var(--grid-size, 16), minmax(0, 1fr));
		grid-template-rows: repeat(var(--grid-size, 16), minmax(0, 1fr));
		border: 1px solid #4b5563; /* gray-600 */
		aspect-ratio: 1 / 1;
		max-width: 70vh; /* Limit size */
		max-height: 70vh;
		margin: auto;
	}
	.lambdoma-cell {
		border: 1px solid #374151; /* gray-700 */
		display: flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		font-size: 0.6rem; /* Adjust as needed */
		line-height: 1;
		text-align: center;
		color: rgba(255, 255, 255, 0.7);
		transition: all 0.1s ease-in-out;
		position: relative;
		overflow: hidden;
	}
	.lambdoma-cell:hover {
		border-color: #d1d5db; /* gray-300 */
		color: white;
		z-index: 10;
		transform: scale(1.1);
		box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
	}
	.lambdoma-cell.active {
		border: 2px solid white;
		transform: scale(1.1);
		z-index: 20;
	}
	#lissajous-canvas {
		border: 1px solid #4b5563; /* gray-600 */
		background-color: #1f2937e0; /* gray-800 with transparency */
		aspect-ratio: 1 / 1;
		width: 100%;
		max-width: 300px; /* Adjust size */
	}
	/* Ensure consistent sizing between grid and canvas containers */
	.keyboard-container {
		max-width: 70vh;
		margin: auto;
	}
	.visual-container {
		max-width: 300px;
	}
</style>
{% endblock %} {% block content %}
<div class="p-4 md:p-8 flex flex-col items-center">
	<h1 class="text-3xl font-serif text-primary mb-6">Lambdoma Keyboard</h1>

	<div
		class="flex flex-col md:flex-row gap-8 items-center justify-center w-full"
	>
		<!-- Lambdoma Grid -->
		<div class="keyboard-container w-full md:w-2/3">
			<div
				id="lambdoma-grid"
				class="lambdoma-grid"
				style="--grid-size: {{ grid_size }};"
			>
				{% for r in range(grid_size) %} {% for c in range(grid_size) %} {% set
				cell = matrix[r][c] %}
				<div
					class="lambdoma-cell"
					style="background-color: {{ cell.color }}30;"
					{#
					Add
					alpha
					transparency
					#}
					title="{{ cell.ratioStr }} | {{ cell.noteName or 'N/A' }} | {{ cell.chakra }} | {{ cell.frequencyHz }} Hz"
					data-row="{{ r + 1 }}"
					{#
					Use
					1-based
					for
					Lissajous
					#}
					data-col="{{ c + 1 }}"
					{#
					Use
					1-based
					for
					Lissajous
					#}
					data-freq="{{ cell.frequencyHz }}"
					data-ratio="{{ cell.ratioStr }}"
					data-color="{{ cell.color }}"
				>
					{{ cell.ratioStr }}
				</div>
				{% endfor %} {% endfor %}
			</div>
		</div>

		<!-- Visual Display -->
		<div class="visual-container w-full md:w-1/3 flex flex-col items-center">
			<h2 class="text-lg font-serif text-secondary mb-4">Harmonic Visual</h2>
			<canvas id="lissajous-canvas" width="300" height="300"></canvas>
			<p id="visual-info" class="text-xs text-text-muted mt-2 text-center">
				Click a cell to visualize resonance
			</p>
		</div>
	</div>

	<div class="mt-4 text-xs text-text-muted">
		Base Frequency: 256 Hz | Grid Size: {{ grid_size }}x{{ grid_size }}
	</div>

	<div class="mt-4 text-center">
		<button
			id="clear-all-button"
			class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded transition-colors"
		>
			Clear All
		</button>
	</div>
</div>

{% endblock %} {% block scripts %}
<script>
	document.addEventListener("DOMContentLoaded", () => {
		const grid = document.getElementById("lambdoma-grid");
		const canvas = document.getElementById("lissajous-canvas");
		const visualInfo = document.getElementById("visual-info");
		const clearAllButton = document.getElementById("clear-all-button");
		const ctx = canvas.getContext("2d");

		let audioContext;
		let activeCells = new Map(); // Map to store active cells and their oscillators

		// --- Task 3: Web Audio Tone Synthesis ---
		function initAudio() {
			if (!audioContext) {
				try {
					audioContext = new (window.AudioContext ||
						window.webkitAudioContext)();
					console.log("Audio context initialized.");
				} catch (e) {
					console.error("Web Audio API is not supported in this browser", e);
					alert("Web Audio API is not supported in this browser");
					return false;
				}
			}
			// Resume context if suspended (often needed after user interaction)
			if (audioContext.state === "suspended") {
				audioContext
					.resume()
					.catch((e) => console.error("Error resuming audio context:", e));
			}
			return true;
		}

		function playTone(freq, pan = 0, duration = 1.5, cellElement) {
			if (!initAudio() || freq <= 0) return null;

			const oscillator = audioContext.createOscillator();
			const gainNode = audioContext.createGain();
			const pannerNode = audioContext.createStereoPanner();

			oscillator.type = "sine";
			oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

			// Envelope: Quick attack, hold, gentle release
			const now = audioContext.currentTime;
			gainNode.gain.setValueAtTime(0.0001, now);
			gainNode.gain.exponentialRampToValueAtTime(0.3, now + 0.05); // Reduced volume for multiple tones

			// Set panning (-1 left, 0 center, 1 right)
			pannerNode.pan.setValueAtTime(pan, now);

			// Connect nodes: Osc -> Gain -> Panner -> Destination
			oscillator.connect(gainNode);
			gainNode.connect(pannerNode);
			pannerNode.connect(audioContext.destination);

			oscillator.start(now);

			// Return audio nodes so we can stop them later
			return {
				oscillator,
				gainNode,
				pannerNode,
				stop: function () {
					try {
						gainNode.gain.cancelScheduledValues(audioContext.currentTime);
						gainNode.gain.linearRampToValueAtTime(
							0.0001,
							audioContext.currentTime + 0.1
						);
						setTimeout(() => {
							oscillator.stop();
							pannerNode.disconnect();
							gainNode.disconnect();
						}, 100);
					} catch (e) {
						console.warn("Error stopping tone:", e);
					}
				},
			};
		}

		// --- Task 4: Visual Resonance Display ---
		function renderLissajous(xRatio, yRatio, canvasCtx, color) {
			const width = canvasCtx.canvas.width;
			const height = canvasCtx.canvas.height;
			const padding = 20;
			const amplitudeX = width / 2 - padding;
			const amplitudeY = height / 2 - padding;
			const delta = Math.PI / 2; // Phase difference
			const points = 500; // Number of points to draw
			const increment = (Math.PI * 2 * Math.max(xRatio, yRatio)) / points; // Adjust speed based on ratio

			canvasCtx.clearRect(0, 0, width, height);
			canvasCtx.beginPath();
			canvasCtx.strokeStyle = color;
			canvasCtx.lineWidth = 1.5;
			canvasCtx.globalAlpha = 0.8;

			let firstX = 0,
				firstY = 0;
			for (let i = 0; i <= points; i++) {
				const t = i * increment;
				const x = amplitudeX * Math.sin(xRatio * t + delta);
				const y = amplitudeY * Math.sin(yRatio * t);
				const screenX = width / 2 + x;
				const screenY = height / 2 + y;

				if (i === 0) {
					canvasCtx.moveTo(screenX, screenY);
					firstX = screenX;
					firstY = screenY;
				} else {
					canvasCtx.lineTo(screenX, screenY);
				}
			}
			// Optional: close the path if it looks better for low ratios
			// canvasCtx.lineTo(firstX, firstY);
			canvasCtx.stroke();
			canvasCtx.globalAlpha = 1.0;
		}

		// New function to update the visualization based on active cells
		function updateVisualization() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			if (activeCells.size === 0) {
				visualInfo.textContent = "Click cells to create harmonies";
				return;
			}

			// For simplicity, just show the last activated cell's Lissajous
			// A more complex implementation could blend multiple patterns
			const lastCell = Array.from(activeCells.entries()).pop();
			if (lastCell) {
				const [cellElement, audioData] = lastCell;
				const row = parseInt(cellElement.dataset.row);
				const col = parseInt(cellElement.dataset.col);
				const color = cellElement.dataset.color;
				renderLissajous(row, col, ctx, color);
			}

			// Update info text to show number of active tones
			visualInfo.textContent = `${activeCells.size} active tone${
				activeCells.size > 1 ? "s" : ""
			}`;
		}

		// Function to clear all active cells
		function clearAllCells() {
			activeCells.forEach((audioNodes, cell) => {
				audioNodes.stop();
				cell.classList.remove("active");
			});
			activeCells.clear();
			updateVisualization();
		}

		// Clear all button event listener
		clearAllButton.addEventListener("click", clearAllCells);

		// --- Task 2: Grid Interaction ---
		grid.addEventListener("click", (event) => {
			const cell = event.target.closest(".lambdoma-cell");
			if (!cell) return;

			const freq = parseFloat(cell.dataset.freq);
			const ratioStr = cell.dataset.ratio;
			const color = cell.dataset.color;
			const row = parseInt(cell.dataset.row); // 1-based
			const col = parseInt(cell.dataset.col); // 1-based
			const gridSize = grid.children.length > 64 ? 16 : 8; // Determine grid size

			// Determine pan based on column position
			const panValue = ((col - 1) / (gridSize - 1)) * 2 - 1;

			// Toggle cell activation
			if (activeCells.has(cell)) {
				// Deactivate cell
				const audioNodes = activeCells.get(cell);
				audioNodes.stop();
				activeCells.delete(cell);
				cell.classList.remove("active");
			} else {
				// Activate cell
				if (!isNaN(freq) && freq > 0) {
					const audioNodes = playTone(freq, panValue, Infinity, cell);
					if (audioNodes) {
						activeCells.set(cell, audioNodes);
						cell.classList.add("active");
					}
				}
			}

			updateVisualization();
		});

		// Initialize audio on first interaction (good practice)
		document.body.addEventListener("click", initAudio, { once: true });
	});
</script>
{% endblock %}
